//! API types for the Refyne SDK.
//!
//! These types are generated from the OpenAPI specification.
//! Do not edit this file manually - run `make generate` to regenerate.
//!
//! Generated from API version: 0.1.65

#![allow(dead_code)]

use serde::{Deserialize, Serialize};

// ============================================================================
// Enums
// ============================================================================

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum AnalyzeInputBodyFetchMode {
    /// auto
    Auto,
    /// static
    Static,
    /// dynamic
    Dynamic,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CleanerOptionsInputOutput {
    /// html
    Html,
    /// text
    Text,
    /// markdown
    Markdown,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CleanerOptionsInputPreset {
    /// default
    Default,
    /// minimal
    Minimal,
    /// aggressive
    Aggressive,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CrawlOptionsFetchMode {
    /// auto
    Auto,
    /// static
    Static,
    /// dynamic
    Dynamic,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CreateSavedSiteInputBodyFetchMode {
    /// auto
    Auto,
    /// static
    Static,
    /// dynamic
    Dynamic,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CreateSchemaInputBodyVisibility {
    /// private
    Private,
    /// public
    Public,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ExtractInputBodyFetchMode {
    /// auto
    Auto,
    /// static
    Static,
    /// dynamic
    Dynamic,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum JobCleanerOptionsInputOutput {
    /// html
    Html,
    /// text
    Text,
    /// markdown
    Markdown,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum JobCleanerOptionsInputPreset {
    /// default
    Default,
    /// minimal
    Minimal,
    /// aggressive
    Aggressive,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum LLMConfigInputProvider {
    /// anthropic
    Anthropic,
    /// openai
    Openai,
    /// openrouter
    Openrouter,
    /// ollama
    Ollama,
    /// helicone
    Helicone,
    /// credits
    Credits,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum UpdateSavedSiteInputBodyFetchMode {
    /// auto
    Auto,
    /// static
    Static,
    /// dynamic
    Dynamic,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum UpdateSchemaInputBodyVisibility {
    /// private
    Private,
    /// public
    Public,
}

// ============================================================================
// Request Types
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AnalysisResultInput {
    /// Detected data elements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detected_elements: Option<serde_json::Value>,
    /// Follow patterns
    #[serde(skip_serializing_if = "Option::is_none")]
    pub follow_patterns: Option<serde_json::Value>,
    /// Detected page type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_type: Option<String>,
    /// Recommended fetch mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommended_fetch_mode: Option<String>,
    /// Sample links found
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sample_links: Option<serde_json::Value>,
    /// Brief site description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub site_summary: Option<String>,
    /// Schema (JSON or YAML format)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_schema: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AnalyzeInputBody {
    /// Enable debug capture to store raw LLM request/response for troubleshooting. Defaults to true for analyze jobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_debug: Option<bool>,
    /// Crawl depth: 0=single page, 1=one level deep
    #[serde(rename = "depth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub depth: Option<i64>,
    /// Fetch mode: auto, static, or dynamic
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch_mode: Option<AnalyzeInputBodyFetchMode>,
    /// URL to analyze
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct CleanerConfigInput {
    /// Cleaner name (noop, refyne)
    pub name: String,
    /// Cleaner-specific options
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<CleanerOptionsInput>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CleanerOptionsInput {
    /// Base URL for resolving relative links
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_url: Option<String>,
    /// Extract heading structure to frontmatter (markdown)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_headings: Option<bool>,
    /// Extract images to frontmatter with {{IMG_001}} placeholders (markdown)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_images: Option<bool>,
    /// Prepend YAML frontmatter with metadata (markdown output)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_frontmatter: Option<bool>,
    /// CSS selectors for elements to always keep
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keep_selectors: Option<serde_json::Value>,
    /// Output format: html, text, or markdown
    #[serde(rename = "output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<CleanerOptionsInputOutput>,
    /// Preset: default, minimal, or aggressive
    #[serde(rename = "preset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preset: Option<CleanerOptionsInputPreset>,
    /// CSS selectors for elements to remove
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_selectors: Option<serde_json::Value>,
    /// Resolve relative URLs to absolute using base_url
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolve_urls: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct CrawlInlineWebhookInput {
    /// Event types to subscribe to (empty for all)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub events: Option<serde_json::Value>,
    /// Custom headers
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    /// Secret for HMAC-SHA256 signature
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    /// Webhook URL
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CrawlOptionsInput {
    /// Regex pattern for URLs to filter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub follow_pattern: Option<String>,
    /// CSS selector for links to follow
    #[serde(skip_serializing_if = "Option::is_none")]
    pub follow_selector: Option<String>,
    /// Max crawl depth
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_depth: Option<i64>,
    /// Max pages (0 = no limit)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_pages: Option<i64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct CrawlWebhookHeaderInput {
    /// Header name
    pub name: String,
    /// Header value
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CreateCrawlJobInputBody {
    /// Enable debug capture to store raw LLM request/response for troubleshooting
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_debug: Option<bool>,
    /// Content cleaner chain (default: [markdown])
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cleaner_chain: Option<serde_json::Value>,
    /// Optional LLM configuration override (BYOK)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub llm_config: Option<LLMConfigInput>,
    /// Crawl configuration options
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<CrawlOptions>,
    /// Extraction instructions - either a structured schema (YAML/JSON with 'name' and 'fields') or freeform natural language prompt. The API auto-detects the format.
    #[serde(rename = "schema")]
    pub schema: serde_json::Value,
    /// Seed URL to start crawling from
    #[serde(rename = "url")]
    pub url: String,
    /// Inline ephemeral webhook configuration
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook: Option<CrawlInlineWebhookInput>,
    /// ID of a saved webhook to call on job events
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_id: Option<String>,
    /// Simple webhook URL (backward compatible)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CreateKeyInputBody {
    /// Expiration date (RFC3339)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<String>,
    /// Descriptive name for the key
    #[serde(rename = "name")]
    pub name: String,
    /// Permitted scopes (extract, crawl, jobs)
    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scopes: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CreatePlatformSchemaInputBody {
    /// Schema category
    #[serde(rename = "category")]
    pub category: String,
    /// Schema description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Schema name
    #[serde(rename = "name")]
    pub name: String,
    /// YAML schema content
    pub schema_yaml: String,
    /// Schema tags
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CreateSavedSiteInputBody {
    /// Analysis result to save
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_result: Option<AnalysisResultInput>,
    /// Crawl options
    #[serde(skip_serializing_if = "Option::is_none")]
    pub crawl_options: Option<CrawlOptionsInput>,
    /// Default schema ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_schema_id: Option<String>,
    /// Fetch mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch_mode: Option<CreateSavedSiteInputBodyFetchMode>,
    /// User-friendly name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Site URL
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSchemaInputBody {
    /// Schema category
    #[serde(rename = "category")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    /// Schema description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Schema name
    #[serde(rename = "name")]
    pub name: String,
    /// YAML schema content
    pub schema_yaml: String,
    /// Schema tags
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    /// Schema visibility
    #[serde(rename = "visibility")]
    pub visibility: CreateSchemaInputBodyVisibility,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct DebugCaptureLLMRequest {
    /// Size of content sent to LLM
    pub content_size: i64,
    /// Position in fallback chain (0=primary)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fallback_position: Option<i64>,
    /// Content fetch mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch_mode: Option<String>,
    /// Preprocessing hints applied
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hints_applied: Option<std::collections::HashMap<String, String>>,
    /// Whether this was a retry attempt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_retry: Option<bool>,
    /// Whether JSON mode was enabled
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_mode: Option<bool>,
    /// Max tokens requested
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<i64>,
    /// LLM model used
    #[serde(rename = "model")]
    pub model: String,
    /// Cleaned page content sent to LLM
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_content: Option<String>,
    /// Full prompt sent to LLM (for analyze jobs)
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,
    /// Total prompt size including system instructions
    pub prompt_size: i64,
    /// LLM provider used
    #[serde(rename = "provider")]
    pub provider: String,
    /// Schema used for extraction
    #[serde(rename = "schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    /// System instructions sent to LLM
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_prompt: Option<String>,
    /// Temperature setting
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
    /// Formatted user content/prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_prompt: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct DetectedElementInput {
    /// Element count
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Element description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Element name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Element type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExtractInputBody {
    /// Enable debug capture to store raw LLM request/response for troubleshooting
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_debug: Option<bool>,
    /// Content cleaner chain (default: [markdown])
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cleaner_chain: Option<serde_json::Value>,
    /// Fetch mode: auto, static, or dynamic
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch_mode: Option<ExtractInputBodyFetchMode>,
    /// Optional LLM configuration override
    #[serde(skip_serializing_if = "Option::is_none")]
    pub llm_config: Option<LLMConfigInput>,
    /// Extraction instructions - either a structured schema (YAML/JSON with 'name' and 'fields') or freeform natural language prompt. The API auto-detects the format and returns 'input_format' in the response.
    #[serde(rename = "schema")]
    pub schema: serde_json::Value,
    /// URL to extract data from
    #[serde(rename = "url")]
    pub url: String,
    /// Inline ephemeral webhook configuration
    #[serde(rename = "webhook")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook: Option<InlineWebhookInput>,
    /// ID of a saved webhook to call on completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_id: Option<String>,
    /// Simple webhook URL (backward compatible)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FallbackChainEntryInput {
    /// Whether this entry is enabled
    pub is_enabled: bool,
    /// Max output tokens (nil for default)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<i64>,
    /// Model identifier
    #[serde(rename = "model")]
    pub model: String,
    /// LLM provider name (see /llm/providers for available options)
    #[serde(rename = "provider")]
    pub provider: String,
    /// Temperature setting (0.0-1.0, nil for default)
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FollowPatternInput {
    /// Pattern description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// URL pattern
    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// Sample matching URLs
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sample_urls: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct InlineWebhookInput {
    /// Event types to subscribe to (empty for all)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub events: Option<serde_json::Value>,
    /// Custom headers
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    /// Secret for HMAC-SHA256 signature
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    /// Webhook URL
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct JobCleanerConfigInput {
    /// Cleaner name (noop, refyne)
    pub name: String,
    /// Cleaner-specific options
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<JobCleanerOptionsInput>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct JobCleanerOptionsInput {
    /// Base URL for resolving relative links
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_url: Option<String>,
    /// Extract heading structure to frontmatter (markdown)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_headings: Option<bool>,
    /// Extract images to frontmatter with {{IMG_001}} placeholders (markdown)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_images: Option<bool>,
    /// Prepend YAML frontmatter with metadata (markdown output)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_frontmatter: Option<bool>,
    /// CSS selectors for elements to always keep
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keep_selectors: Option<serde_json::Value>,
    /// Output format: html, text, or markdown
    #[serde(rename = "output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<JobCleanerOptionsInputOutput>,
    /// Preset: default, minimal, or aggressive
    #[serde(rename = "preset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preset: Option<JobCleanerOptionsInputPreset>,
    /// CSS selectors for elements to remove
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_selectors: Option<serde_json::Value>,
    /// Resolve relative URLs to absolute using base_url
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolve_urls: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct LLMConfigInput {
    /// API key for the provider
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<String>,
    /// Custom base URL (for Ollama or self-hosted Helicone)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_url: Option<String>,
    /// Model to use
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,
    /// LLM provider
    #[serde(rename = "provider")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<LLMConfigInputProvider>,
    /// Underlying provider's API key for Helicone self-hosted mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_api_key: Option<String>,
    /// Underlying provider for Helicone self-hosted mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_provider: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ModelValidationRequest {
    /// Model identifier
    pub model: String,
    /// Provider name
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ServiceKeyInput {
    /// API key for the provider (required for new keys, optional for updates)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<String>,
    /// Whether this provider is enabled
    pub is_enabled: bool,
    /// LLM provider name (see /llm/providers for available options)
    #[serde(rename = "provider")]
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct SetFallbackChainInputBody {
    /// Ordered list of provider:model pairs
    pub chain: serde_json::Value,
    /// Tier to set chain for (null for default chain)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct SetUserFallbackChainInputBody {
    /// Ordered list of provider:model pairs
    pub chain: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TierValidationRequest {
    /// Tier ID or slug to validate
    pub tier_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UpdateSavedSiteInputBody {
    /// Analysis result to update
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_result: Option<AnalysisResultInput>,
    /// Crawl options
    #[serde(skip_serializing_if = "Option::is_none")]
    pub crawl_options: Option<CrawlOptionsInput>,
    /// Default schema ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_schema_id: Option<String>,
    /// Fetch mode
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fetch_mode: Option<UpdateSavedSiteInputBodyFetchMode>,
    /// User-friendly name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Site URL (ignored on update)
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UpdateSchemaInputBody {
    /// Schema category
    #[serde(rename = "category")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    /// Schema description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Schema name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// YAML schema content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_yaml: Option<String>,
    /// Schema tags
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    /// Schema visibility
    #[serde(rename = "visibility")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub visibility: Option<UpdateSchemaInputBodyVisibility>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UserFallbackChainEntryInput {
    /// Whether this entry is enabled
    pub is_enabled: bool,
    /// Max output tokens (nil for default)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<i64>,
    /// Model identifier
    #[serde(rename = "model")]
    pub model: String,
    /// LLM provider name (see /llm/providers for available options)
    #[serde(rename = "provider")]
    pub provider: String,
    /// Temperature setting (0.0-1.0, nil for default)
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UserServiceKeyInput {
    /// API key for the provider (leave empty to keep existing)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<String>,
    /// Base URL for the provider (for Ollama or custom endpoints)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_url: Option<String>,
    /// Whether this provider is enabled
    pub is_enabled: bool,
    /// LLM provider name (see /llm/providers for available options)
    #[serde(rename = "provider")]
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ValidateModelsInputBody {
    /// Models to validate
    pub models: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ValidateTiersInputBody {
    /// Tiers to validate
    pub tiers: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct WebhookHeaderInput {
    /// Header name
    pub name: String,
    /// Header value
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct WebhookInput {
    /// Event types to subscribe to (empty or ["*"] for all events)
    #[serde(rename = "events")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub events: Option<serde_json::Value>,
    /// Custom headers to include in webhook requests
    #[serde(rename = "headers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    /// Whether this webhook is active
    pub is_active: bool,
    /// Unique name for this webhook
    #[serde(rename = "name")]
    pub name: String,
    /// Secret for HMAC-SHA256 signature (leave empty to disable signing)
    #[serde(rename = "secret")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    /// Webhook URL to send events to
    #[serde(rename = "url")]
    pub url: String,
}

// ============================================================================
// Response Types
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct APIKeyResponse {
    pub created_at: String,
    pub expires_at: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub key_prefix: String,
    pub last_used_at: Option<String>,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "scopes")]
    pub scopes: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdminJobResultsOutputBody {
    /// Presigned URL to download results (valid for 1 hour)
    pub download_url: String,
    /// URL expiration time
    pub expires_at: String,
    /// Job ID
    pub job_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisResultOutput {
    /// Detected data elements
    pub detected_elements: serde_json::Value,
    /// Follow patterns
    pub follow_patterns: serde_json::Value,
    /// Detected page type
    pub page_type: String,
    /// Recommended fetch mode
    pub recommended_fetch_mode: String,
    /// Sample links found
    pub sample_links: serde_json::Value,
    /// Brief site description
    pub site_summary: String,
    /// Schema suggestion (JSON format)
    pub suggested_schema: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyticsJobResponse {
    pub completed_at: Option<String>,
    pub cost_usd: f64,
    pub created_at: String,
    pub discovery_method: Option<String>,
    pub error_category: Option<String>,
    pub error_message: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub is_byok: bool,
    pub llm_cost_usd: f64,
    #[serde(rename = "model")]
    pub model: Option<String>,
    #[serde(rename = "provider")]
    pub provider: Option<String>,
    #[serde(rename = "status")]
    pub status: String,
    pub tokens_input: i64,
    pub tokens_output: i64,
    #[serde(rename = "type")]
    pub r#type: String,
    #[serde(rename = "url")]
    pub url: String,
    pub user_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzeResponseBody {
    /// Data elements detected on the page
    pub detected_elements: serde_json::Value,
    /// URL/selector patterns for crawling
    pub follow_patterns: serde_json::Value,
    /// Unique job ID for this analysis (for tracking/history)
    pub job_id: String,
    /// Detected page type: listing, detail, article, product, recipe, unknown
    pub page_type: String,
    /// Recommended fetch mode: static or dynamic
    pub recommended_fetch_mode: String,
    /// Optional preview extraction result
    pub sample_data: Option<serde_json::Value>,
    /// Sample links found on the page
    pub sample_links: serde_json::Value,
    /// Brief description of what the site/page is about
    pub site_summary: String,
    /// Schema suggestion for extraction (JSON format)
    pub suggested_schema: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CleanerChainItemResponse {
    /// Cleaner name
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CleanerOptionResponse {
    /// Default value if not specified
    pub default: serde_json::Value,
    /// Description of what this option does
    pub description: String,
    /// Option name (e.g., 'output', 'tables')
    pub name: String,
    /// Option type (string, boolean)
    pub r#type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CleanerResponse {
    /// Description of what this cleaner does
    pub description: String,
    /// Cleaner name to use in cleaner_chain
    pub name: String,
    /// Available options for this cleaner
    pub options: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrawlJobResponseBody {
    /// Total USD cost charged (sync mode)
    pub cost_usd: Option<f64>,
    /// Merged extraction results from all pages (sync mode, completed only)
    #[serde(rename = "data")]
    pub data: Option<std::collections::HashMap<String, serde_json::Value>>,
    /// Total job duration in milliseconds (sync mode)
    pub duration_ms: Option<i64>,
    /// Error message if job failed or timed out
    pub error_message: Option<String>,
    /// Unique job identifier (ULID)
    pub job_id: String,
    /// Number of pages successfully extracted (sync mode)
    pub page_count: Option<i64>,
    /// Job status: pending, running, completed, failed
    #[serde(rename = "status")]
    pub status: String,
    /// URL to poll for job status (async mode)
    pub status_url: Option<String>,
    /// Token usage statistics (sync mode)
    pub token_usage: Option<TokenUsage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrawlOptionsOutput {
    /// Regex pattern for URLs to filter
    pub follow_pattern: Option<String>,
    /// CSS selector for links to follow
    pub follow_selector: Option<String>,
    /// Max crawl depth
    pub max_depth: Option<i64>,
    /// Max pages (0 = no limit)
    pub max_pages: Option<i64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateKeyOutputBody {
    pub created_at: String,
    pub expires_at: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    /// Full API key - only shown once!
    #[serde(rename = "key")]
    pub key: String,
    pub key_prefix: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "scopes")]
    pub scopes: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugCaptureLLMResponse {
    /// Cost of this request in USD
    pub cost_usd: Option<f64>,
    /// Request duration in milliseconds
    pub duration_ms: i64,
    /// Error message if failed
    #[serde(rename = "error")]
    pub error: Option<String>,
    /// Error classification
    pub error_category: Option<String>,
    /// Input tokens consumed
    pub input_tokens: i64,
    /// Output tokens generated
    pub output_tokens: i64,
    /// Error if JSON parsing failed
    pub parse_error: Option<String>,
    /// Structured data (if successfully parsed)
    pub parsed_output: Option<serde_json::Value>,
    /// Raw LLM response text
    pub raw_output: Option<String>,
    /// Whether the request succeeded
    #[serde(rename = "success")]
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeleteSavedSiteOutputBody {
    /// Whether deletion was successful
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeleteSchemaOutputBody {
    /// Whether deletion was successful
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeleteServiceKeyOutputBody {
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeleteUserServiceKeyOutputBody {
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeleteWebhookOutputBody {
    /// Whether deletion was successful
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DetectedElementOutput {
    /// Number of occurrences
    pub count: Option<i64>,
    /// What this element represents
    pub description: String,
    /// Suggested field name
    pub name: String,
    /// Data type: string, number, boolean, array, url, date
    pub r#type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadJobDebugCaptureOutputBody {
    /// Signed URL for downloading the debug capture file
    pub download_url: String,
    /// When the download URL expires
    pub expires_at: String,
    /// Suggested filename for the download
    #[serde(rename = "filename")]
    pub filename: String,
    /// Job ID
    pub job_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorCategoryResponse {
    #[serde(rename = "category")]
    pub category: String,
    #[serde(rename = "count")]
    pub count: i64,
    #[serde(rename = "percentage")]
    pub percentage: f64,
    pub sample_messages: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtractOutputBody {
    /// Extracted data matching the schema
    #[serde(rename = "data")]
    pub data: serde_json::Value,
    /// Timestamp when the page was fetched
    pub fetched_at: String,
    /// How the input was interpreted: 'schema' (structured YAML/JSON) or 'prompt' (freeform text)
    pub input_format: String,
    /// Job ID for this extraction (for history/tracking)
    pub job_id: String,
    /// Extraction metadata
    #[serde(rename = "metadata")]
    pub metadata: MetadataResponse,
    /// URL that was extracted
    #[serde(rename = "url")]
    pub url: String,
    /// Token usage information
    #[serde(rename = "usage")]
    pub usage: UsageResponse,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FailingURLResponse {
    pub count: i64,
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FallbackChainEntryResponse {
    pub created_at: String,
    #[serde(rename = "id")]
    pub id: String,
    pub is_enabled: bool,
    pub max_tokens: Option<i64>,
    #[serde(rename = "model")]
    pub model: String,
    #[serde(rename = "position")]
    pub position: i64,
    #[serde(rename = "provider")]
    pub provider: String,
    #[serde(rename = "temperature")]
    pub temperature: Option<f64>,
    #[serde(rename = "tier")]
    pub tier: Option<String>,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FollowPatternOutput {
    /// What this pattern targets
    #[serde(rename = "description")]
    pub description: String,
    /// CSS selector or URL pattern
    #[serde(rename = "pattern")]
    pub pattern: String,
    /// Example URLs matching this pattern
    pub sample_urls: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAnalyticsJobsOutputBody {
    #[serde(rename = "jobs")]
    pub jobs: serde_json::Value,
    pub total_count: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAnalyticsUsersOutputBody {
    pub total_count: i64,
    #[serde(rename = "users")]
    pub users: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCrawlMapOutputBody {
    /// Number of successfully completed pages
    #[serde(rename = "completed")]
    pub completed: i64,
    /// Crawl map entries ordered by depth
    #[serde(rename = "entries")]
    pub entries: serde_json::Value,
    /// Summary of errors if any pages failed
    pub error_summary: Option<ErrorSummary>,
    /// Number of failed pages
    #[serde(rename = "failed")]
    pub failed: i64,
    /// Job ID
    pub job_id: String,
    /// Maximum depth reached
    pub max_depth: i64,
    /// Initial seed URL
    pub seed_url: String,
    /// Total pages in crawl map
    #[serde(rename = "total")]
    pub total: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetErrorsOutputBody {
    pub by_category: serde_json::Value,
    pub by_provider: serde_json::Value,
    pub top_failing_urls: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetFallbackChainOutputBody {
    pub chain: serde_json::Value,
    pub tiers: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetJobDebugCaptureOutputBody {
    /// API version that processed this job
    pub api_version: Option<String>,
    /// Captured LLM requests
    #[serde(rename = "captures")]
    pub captures: serde_json::Value,
    /// Whether debug capture was enabled for this job
    #[serde(rename = "enabled")]
    pub enabled: bool,
    /// Whether user's own API key was used
    pub is_byok: Option<bool>,
    /// Job ID
    pub job_id: String,
    /// Job type (analyze, extract, crawl)
    pub job_type: Option<String>,
    /// Total cost in USD
    pub total_cost_usd: Option<f64>,
    /// Total duration in milliseconds
    pub total_duration_ms: Option<i64>,
    /// Number of LLM requests
    pub total_requests: Option<i64>,
    /// Total input tokens
    pub total_tokens_in: Option<i64>,
    /// Total output tokens
    pub total_tokens_out: Option<i64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetJobResultsDownloadOutputBody {
    /// Presigned URL to download results (valid for 1 hour)
    pub download_url: String,
    /// URL expiration time
    pub expires_at: String,
    /// Job ID
    pub job_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetJobWebhookDeliveriesOutputBody {
    /// Webhook deliveries for this job
    #[serde(rename = "deliveries")]
    pub deliveries: serde_json::Value,
    /// Job ID
    pub job_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetTrendsOutputBody {
    pub trends: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUsageOutputBody {
    /// Jobs using user's own API keys (not charged)
    pub byok_jobs: i64,
    /// Total USD charged for usage
    pub total_charged_usd: f64,
    /// Total number of jobs
    pub total_jobs: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetUserFallbackChainOutputBody {
    pub chain: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HealthCheckOutputBody {
    pub status: String,
    pub version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobResponse {
    pub capture_debug: bool,
    pub completed_at: Option<String>,
    pub cost_usd: f64,
    pub created_at: String,
    pub error_category: Option<String>,
    pub error_message: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub page_count: i64,
    pub started_at: Option<String>,
    #[serde(rename = "status")]
    pub status: String,
    pub token_usage_input: i64,
    pub token_usage_output: i64,
    #[serde(rename = "type")]
    pub r#type: String,
    #[serde(rename = "url")]
    pub url: String,
    pub urls_queued: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobWebhookDeliveryResponse {
    /// Current attempt number
    pub attempt_number: i64,
    /// Creation timestamp
    pub created_at: String,
    /// Successful delivery timestamp
    pub delivered_at: Option<String>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Event type that triggered this delivery
    pub event_type: String,
    /// Delivery ID
    #[serde(rename = "id")]
    pub id: String,
    /// Maximum retry attempts
    pub max_attempts: i64,
    /// Response time in milliseconds
    pub response_time_ms: Option<i64>,
    /// Delivery status (pending, success, failed, retrying)
    #[serde(rename = "status")]
    pub status: String,
    /// HTTP status code received
    pub status_code: Option<i64>,
    /// Destination URL
    #[serde(rename = "url")]
    pub url: String,
    /// Webhook ID (null for ephemeral)
    pub webhook_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListAllSchemasOutputBody {
    /// List of all schemas
    pub schemas: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListCleanersOutputBody {
    /// List of available cleaners
    #[serde(rename = "cleaners")]
    pub cleaners: serde_json::Value,
    /// Default cleaner chain for analysis operations
    pub default_analysis_chain: serde_json::Value,
    /// Default cleaner chain for extraction operations
    pub default_extraction_chain: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListJobsOutputBody {
    pub jobs: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListKeysOutputBody {
    pub keys: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListModelsOutputBody {
    pub models: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListProvidersOutputBody {
    pub providers: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListSavedSitesOutputBody {
    /// List of saved sites
    pub sites: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListSchemasOutputBody {
    /// List of schemas
    pub schemas: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListServiceKeysOutputBody {
    pub keys: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListTierLimitsOutputBody {
    /// List of visible tiers and their limits
    pub tiers: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListTiersOutputBody {
    pub tiers: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListUserServiceKeysOutputBody {
    pub keys: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListWebhookDeliveriesOutputBody {
    /// List of webhook deliveries
    pub deliveries: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ListWebhooksOutputBody {
    /// List of user's webhooks
    pub webhooks: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LivezOutputBody {
    /// Liveness status
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataResponse {
    /// Time to extract data in milliseconds
    pub extract_duration_ms: i64,
    /// Time to fetch the page in milliseconds
    pub fetch_duration_ms: i64,
    /// Model used for extraction
    #[serde(rename = "model")]
    pub model: String,
    /// LLM provider used
    #[serde(rename = "provider")]
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelValidationResponse {
    pub message: Option<String>,
    pub model: String,
    pub provider: String,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OverviewResponse {
    /// Number of unique users with jobs
    pub active_users: i64,
    /// Jobs using user API keys
    pub byok_jobs: i64,
    /// Number of completed jobs
    pub completed_jobs: i64,
    /// Error rate percentage
    pub error_rate: f64,
    /// Number of failed jobs
    pub failed_jobs: i64,
    /// Jobs using platform API keys
    pub platform_jobs: i64,
    /// Total cost in USD
    pub total_cost_usd: f64,
    /// Total number of jobs
    pub total_jobs: i64,
    /// Total input tokens
    pub total_tokens_input: i64,
    /// Total output tokens
    pub total_tokens_output: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProviderErrorResponse {
    pub count: i64,
    pub model: String,
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderModelResponse {
    pub context_size: Option<i64>,
    #[serde(rename = "description")]
    pub description: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub is_free: bool,
    #[serde(rename = "name")]
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReadyzOutputBody {
    /// Readiness status
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RevokeKeyOutputBody {
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedSiteOutput {
    /// Analysis result
    pub analysis_result: Option<AnalysisResultOutput>,
    /// Saved crawl options
    pub crawl_options: Option<CrawlOptionsOutput>,
    /// Creation timestamp
    pub created_at: String,
    /// Default schema to use
    pub default_schema_id: Option<String>,
    /// Extracted domain
    #[serde(rename = "domain")]
    pub domain: String,
    /// Fetch mode: auto, static, dynamic
    pub fetch_mode: String,
    /// Site ID
    #[serde(rename = "id")]
    pub id: String,
    /// User-friendly name
    #[serde(rename = "name")]
    pub name: Option<String>,
    /// Organization ID for sharing
    pub organization_id: Option<String>,
    /// Last update timestamp
    pub updated_at: String,
    /// Site URL
    #[serde(rename = "url")]
    pub url: String,
    /// Owner user ID
    pub user_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaOutput {
    /// Schema category
    #[serde(rename = "category")]
    pub category: Option<String>,
    /// Creation timestamp
    pub created_at: String,
    /// Schema description
    #[serde(rename = "description")]
    pub description: Option<String>,
    /// Schema ID
    #[serde(rename = "id")]
    pub id: String,
    /// True for admin-managed schemas
    pub is_platform: bool,
    /// Schema name
    #[serde(rename = "name")]
    pub name: String,
    /// Organization ID (Clerk)
    pub organization_id: Option<String>,
    /// YAML schema content
    pub schema_yaml: String,
    /// Schema tags
    #[serde(rename = "tags")]
    pub tags: Option<serde_json::Value>,
    /// Last update timestamp
    pub updated_at: String,
    /// Number of times schema has been used
    pub usage_count: i64,
    /// Creator user ID
    pub user_id: Option<String>,
    /// Visibility: platform, public, private
    #[serde(rename = "visibility")]
    pub visibility: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceKeyResponse {
    pub created_at: String,
    pub has_key: bool,
    pub is_enabled: bool,
    #[serde(rename = "provider")]
    pub provider: String,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SetFallbackChainOutputBody {
    pub chain: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SetUserFallbackChainOutputBody {
    pub chain: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubscriptionTierResponse {
    #[serde(rename = "description")]
    pub description: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub is_default: bool,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "slug")]
    pub slug: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SyncTiersOutputBody {
    /// Sync result message
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TierLimitsResponse {
    /// Monthly USD credit for premium model calls (0 = none)
    pub credit_allocation_usd: f64,
    /// Credit expiry: -1 = never, 0 = current period, N = N additional periods
    pub credit_rollover_months: i64,
    /// Human-readable tier name (from Clerk Commerce)
    pub display_name: String,
    /// Max concurrent jobs (0 = unlimited)
    pub max_concurrent_jobs: i64,
    /// Max pages per crawl job (0 = unlimited)
    pub max_pages_per_crawl: i64,
    /// Monthly extraction limit (0 = unlimited)
    pub monthly_extractions: i64,
    /// Tier name (free, standard, pro, selfhosted)
    #[serde(rename = "name")]
    pub name: String,
    /// API requests per minute limit (0 = unlimited)
    pub requests_per_minute: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TierValidationResponse {
    pub current_slug: Option<String>,
    #[serde(rename = "message")]
    pub message: Option<String>,
    #[serde(rename = "status")]
    pub status: String,
    pub tier_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrendPointResponse {
    pub cost_usd: f64,
    #[serde(rename = "date")]
    pub date: String,
    pub error_count: i64,
    pub job_count: i64,
    #[serde(rename = "tokens")]
    pub tokens: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageResponse {
    /// Total USD cost charged for this extraction
    pub cost_usd: f64,
    /// Number of input tokens used
    pub input_tokens: i64,
    /// True if user's own API key was used (no charge)
    pub is_byok: bool,
    /// Actual LLM cost from provider
    pub llm_cost_usd: f64,
    /// Number of output tokens used
    pub output_tokens: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserFallbackChainEntryResponse {
    pub created_at: String,
    #[serde(rename = "id")]
    pub id: String,
    pub is_enabled: bool,
    pub max_tokens: Option<i64>,
    #[serde(rename = "model")]
    pub model: String,
    #[serde(rename = "position")]
    pub position: i64,
    #[serde(rename = "provider")]
    pub provider: String,
    #[serde(rename = "temperature")]
    pub temperature: Option<f64>,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UserListModelsOutputBody {
    pub models: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserModelResponse {
    pub context_size: Option<i64>,
    #[serde(rename = "description")]
    pub description: Option<String>,
    #[serde(rename = "id")]
    pub id: String,
    pub is_free: bool,
    #[serde(rename = "name")]
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserServiceKeyResponse {
    pub base_url: Option<String>,
    pub created_at: String,
    pub has_key: bool,
    #[serde(rename = "id")]
    pub id: String,
    pub is_enabled: bool,
    #[serde(rename = "provider")]
    pub provider: String,
    pub updated_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserSummaryResponse {
    pub completed_jobs: i64,
    pub failed_jobs: i64,
    pub last_active: Option<String>,
    pub total_cost_usd: f64,
    pub total_jobs: i64,
    pub total_tokens: i64,
    pub user_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ValidateModelsOutputBody {
    pub results: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ValidateTiersOutputBody {
    pub results: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebhookDeliveryResponse {
    /// Current attempt number
    pub attempt_number: i64,
    /// Creation timestamp
    pub created_at: String,
    /// Successful delivery timestamp
    pub delivered_at: Option<String>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Event type that triggered this delivery
    pub event_type: String,
    /// Delivery ID
    #[serde(rename = "id")]
    pub id: String,
    /// Associated job ID
    pub job_id: String,
    /// Maximum retry attempts
    pub max_attempts: i64,
    /// Next retry time if retrying
    pub next_retry_at: Option<String>,
    /// Response time in milliseconds
    pub response_time_ms: Option<i64>,
    /// Delivery status (pending, success, failed, retrying)
    #[serde(rename = "status")]
    pub status: String,
    /// HTTP status code received
    pub status_code: Option<i64>,
    /// Destination URL
    #[serde(rename = "url")]
    pub url: String,
    /// Webhook ID (null for ephemeral webhooks)
    pub webhook_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebhookResponse {
    /// Creation timestamp
    pub created_at: String,
    /// Subscribed event types
    #[serde(rename = "events")]
    pub events: serde_json::Value,
    /// Whether this webhook has a secret configured
    pub has_secret: bool,
    /// Custom headers
    #[serde(rename = "headers")]
    pub headers: Option<serde_json::Value>,
    /// Unique webhook ID
    #[serde(rename = "id")]
    pub id: String,
    /// Whether this webhook is active
    pub is_active: bool,
    /// Webhook name
    #[serde(rename = "name")]
    pub name: String,
    /// Last update timestamp
    pub updated_at: String,
    /// Webhook URL
    #[serde(rename = "url")]
    pub url: String,
}

// ============================================================================
// Other Types
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrawlMapEntry {
    /// When processing completed
    pub completed_at: Option<String>,
    /// Crawl depth (0 for seed URL)
    #[serde(rename = "depth")]
    pub depth: i64,
    /// When URL was discovered
    pub discovered_at: Option<String>,
    /// Error classification: rate_limit, quota_exceeded, provider_error, invalid_key, context_length, invalid_response, network_error, unknown
    pub error_category: Option<String>,
    /// Full error details (BYOK users only)
    pub error_details: Option<String>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Time to extract data in ms
    pub extract_duration_ms: i64,
    /// Time to fetch page in ms
    pub fetch_duration_ms: i64,
    /// Result ID
    #[serde(rename = "id")]
    pub id: String,
    /// LLM model used (BYOK users only)
    pub llm_model: Option<String>,
    /// LLM provider used (BYOK users only)
    pub llm_provider: Option<String>,
    /// URL that discovered this page (null for seed)
    pub parent_url: Option<String>,
    /// Crawl status: pending, crawling, completed, failed, skipped
    #[serde(rename = "status")]
    pub status: String,
    /// Input tokens used
    pub token_usage_input: i64,
    /// Output tokens used
    pub token_usage_output: i64,
    /// Page URL
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrawlOptions {
    /// Concurrent extraction requests
    #[serde(rename = "concurrency")]
    pub concurrency: Option<i64>,
    /// Delay between requests (e.g., 500ms, 1s, 2s)
    #[serde(rename = "delay")]
    pub delay: Option<String>,
    /// Extract data from the seed URL (not just discovered pages)
    pub extract_from_seeds: Option<bool>,
    /// Page fetching mode: auto (detect and retry with browser if needed), static (fast, Colly-based), dynamic (browser rendering for JS-heavy sites, requires content_dynamic feature)
    pub fetch_mode: Option<CrawlOptionsFetchMode>,
    /// Regex pattern to filter URLs. Only matching URLs are crawled.
    pub follow_pattern: Option<String>,
    /// CSS selector(s) for links to follow. Comma-separated or newline-separated.
    pub follow_selector: Option<String>,
    /// Maximum crawl depth from seed URL (1 = seed + direct links)
    pub max_depth: Option<i64>,
    /// Maximum total pages to crawl (0 = no limit, up to tier max)
    pub max_pages: Option<i64>,
    /// Maximum URLs to discover and queue
    pub max_urls: Option<i64>,
    /// CSS selector for pagination 'next' link
    pub next_selector: Option<String>,
    /// Only follow links on the same domain as seed URL
    pub same_domain_only: Option<bool>,
    /// Discover URLs from sitemap.xml instead of CSS selectors
    pub use_sitemap: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugCaptureEntry {
    /// API version that processed this request
    pub api_version: Option<String>,
    /// Capture ID
    #[serde(rename = "id")]
    pub id: String,
    /// Whether user's own API key was used
    pub is_byok: Option<bool>,
    /// Job type (analyze, extract, crawl)
    pub job_type: String,
    /// LLM request with metadata and payload
    #[serde(rename = "request")]
    pub request: DebugCaptureLLMRequest,
    /// LLM response with metadata and payload
    #[serde(rename = "response")]
    pub response: DebugCaptureLLMResponse,
    /// Order within job (0-indexed)
    #[serde(rename = "sequence")]
    pub sequence: Option<i64>,
    /// When the request was made
    #[serde(rename = "timestamp")]
    pub timestamp: String,
    /// Page URL being processed
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ErrorDetail {
    /// Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
    pub location: Option<String>,
    /// Error message text
    pub message: Option<String>,
    /// The value at the given location
    pub value: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ErrorModel {
    /// A human-readable explanation specific to this occurrence of the problem.
    pub detail: Option<String>,
    /// Optional list of individual error details
    pub errors: Option<serde_json::Value>,
    /// A URI reference that identifies the specific occurrence of the problem.
    pub instance: Option<String>,
    /// HTTP status code
    pub status: Option<i64>,
    /// A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
    pub title: Option<String>,
    /// A URI reference to human-readable documentation for the error.
    pub r#type: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorSummary {
    /// Count of errors by category (rate_limit, quota_exceeded, etc.)
    pub by_category: std::collections::HashMap<String, i64>,
    /// True if any rate_limit errors occurred
    pub has_rate_limit: bool,
    /// Total number of failed pages
    #[serde(rename = "total")]
    pub total: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobQueueStats {
    /// Pending jobs by tier
    pub pending_by_tier: std::collections::HashMap<String, i64>,
    /// Total pending jobs
    pub pending_total: i64,
    /// Running jobs by tier
    pub running_by_tier: std::collections::HashMap<String, i64>,
    /// Running jobs by user ID
    pub running_by_user: std::collections::HashMap<String, i64>,
    /// Total running jobs
    pub running_total: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderInfo {
    pub allow_base_url_override: bool,
    pub base_url_hint: Option<String>,
    pub decommission_note: Option<String>,
    #[serde(rename = "description")]
    pub description: String,
    pub display_name: String,
    pub docs_url: Option<String>,
    pub key_placeholder: Option<String>,
    #[serde(rename = "name")]
    pub name: String,
    pub required_features: Option<serde_json::Value>,
    pub requires_key: bool,
    #[serde(rename = "status")]
    pub status: String,
    pub successor_provider: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RateLimitStats {
    /// Number of currently suspended API keys
    pub active_suspensions: i64,
    /// Total rate limit entries in database
    pub total_entries: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSECompleteEvent {
    /// Total cost in USD
    pub cost_usd: Option<f64>,
    /// Error category if job failed
    pub error_category: Option<String>,
    /// Error message if job failed
    pub error_message: Option<String>,
    /// Job ID
    pub job_id: String,
    /// Total pages processed
    pub page_count: i64,
    /// URL to fetch full results
    pub results_url: String,
    /// Final job status
    #[serde(rename = "status")]
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SSEErrorEvent {
    /// Error message
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSEResultEvent {
    /// Error category if failed
    pub error_category: Option<String>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Result ID
    #[serde(rename = "id")]
    pub id: String,
    /// LLM model used
    pub llm_model: Option<String>,
    /// LLM provider used
    pub llm_provider: Option<String>,
    /// Crawl status (pending, completed, failed)
    #[serde(rename = "status")]
    pub status: String,
    /// Source URL
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSEStatusEvent {
    /// Job ID
    pub job_id: String,
    /// Number of pages processed so far
    pub page_count: i64,
    /// Job status (pending, running, completed, failed)
    #[serde(rename = "status")]
    pub status: String,
    /// Number of URLs queued for processing
    pub urls_queued: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemMetrics {
    /// Job queue statistics
    pub job_queue: JobQueueStats,
    /// API key rate limit statistics
    pub rate_limits: RateLimitStats,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TokenUsage {
    /// Total input tokens consumed across all extractions
    pub input: i64,
    /// Total output tokens generated across all extractions
    pub output: i64,
}

// ============================================================================
// Additional Types (not in OpenAPI spec but required by SDK)
// ============================================================================

/// Response containing available LLM providers.
#[derive(Debug, Clone, Deserialize)]
pub struct ProvidersResponse {
    /// List of available provider names.
    pub providers: Vec<String>,
}

/// Available LLM model.
#[derive(Debug, Clone, Deserialize)]
pub struct Model {
    /// Model identifier.
    pub id: String,
    /// Display name.
    pub name: String,
}

// ==========================================================================
// Type Aliases for Client Compatibility
// ==========================================================================

/// Single job response.
pub type Job = JobResponse;

/// Job list response.
pub type JobList = ListJobsOutputBody;

/// Job extraction results (dynamic JSON).
pub type JobResults = serde_json::Value;

/// Schema response.
pub type Schema = SchemaOutput;

/// Schema list response.
pub type SchemaList = ListSchemasOutputBody;

/// Schema creation request.
pub type CreateSchemaRequest = CreateSchemaInputBody;

/// Saved site response.
pub type Site = SavedSiteOutput;

/// Saved site list response.
pub type SiteList = ListSavedSitesOutputBody;

/// Site creation request.
pub type CreateSiteRequest = CreateSavedSiteInputBody;

/// API key list response.
pub type ApiKeyList = ListKeysOutputBody;

/// API key creation response.
pub type ApiKeyCreated = CreateKeyOutputBody;

/// User LLM service key response.
pub type LlmKey = UserServiceKeyResponse;

/// LLM service key list response.
pub type LlmKeyList = ListUserServiceKeysOutputBody;

/// LLM key upsert request.
pub type UpsertLlmKeyRequest = UserServiceKeyInput;

/// LLM fallback chain.
pub type LlmChain = GetUserFallbackChainOutputBody;

/// LLM fallback chain entry.
pub type LlmChainEntry = UserFallbackChainEntryInput;

/// Model list response.
pub type ModelList = UserListModelsOutputBody;

/// Extract request.
pub type ExtractRequest = ExtractInputBody;

/// Extract response.
pub type ExtractResponse = ExtractOutputBody;

/// Crawl request.
pub type CrawlRequest = CreateCrawlJobInputBody;

/// Crawl job created response.
pub type CrawlJobCreated = CrawlJobResponseBody;

/// Analyze request.
pub type AnalyzeRequest = AnalyzeInputBody;

/// Analyze response.
pub type AnalyzeResponse = AnalyzeResponseBody;
